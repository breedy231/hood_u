var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// IMLEMENTATION NOTES: Why new layers are created on every render
//
// The key here is to understand the declarative / functional
// programming nature of "reactive" applications.
//
// - In a reactive application, the entire "UI tree"
//   is re-rendered every time something in the application changes.
//
// - The UI framework (such as React or deck.gl) then diffs the rendered
//   tree of UI elements (React Elements or deck.gl Layers) against the
//   previously tree and makes optimized changes (to the DOM or to WebGL state).
//
// - Deck.gl layers are not based on React.
//   But it should be possible to wrap deck.gl layers in React components to
//   enable use of JSX.
//
// The deck.gl model that for the app creates a new set of on layers on every
// render.
// Internally, the new layers are efficiently matched against existing layers
// using layer ids.
//
// All calculated state (programs, attributes etc) are stored in a state object
// and this state object is moved forward to the match layer on every render
// cycle.  The new layer ends up with the state of the old layer (and the
// props of the new layer), while the old layer is simply discarded for
// garbage collecion.
//
/* eslint-disable no-try-catch */
import Layer from './layer';
import { log } from './utils';
import assert from 'assert';
import { drawLayers as _drawLayers, pickLayers } from './draw-and-pick';
import { LIFECYCLE } from './constants';
import { Viewport } from './viewports';

import { FramebufferObject } from 'luma.gl';

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 3;

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    this.prevLayers = [];
    this.layers = [];
    // Tracks if any layers were drawn last update
    // Needed to ensure that screen is cleared when no layers are shown
    this.screenCleared = false;
    this.oldContext = {};
    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      lastPickedInfo: {
        index: -1,
        layerId: null
      }
    };
    Object.seal(this.context);
  }

  _createClass(LayerManager, [{
    key: 'setViewport',
    value: function setViewport(viewport) {
      assert(viewport instanceof Viewport, 'Invalid viewport');

      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        log(4, viewport);
      }

      return this;
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref2) {
      var newLayers = _ref2.newLayers;

      /* eslint-disable */
      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref3) {
      var pass = _ref3.pass;

      assert(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      _drawLayers({ layers: this.layers, pass: pass });

      return this;
    }
  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          mode = _ref4.mode;
      var _context = this.context,
          gl = _context.gl,
          uniforms = _context.uniforms;

      // Set up a frame buffer if needed

      if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {
        this.context.pickingFBO = new FramebufferObject(gl, {
          width: gl.canvas.width,
          height: gl.canvas.height
        });
      }
      return pickLayers(gl, {
        x: x,
        y: y,
        uniforms: {
          renderPickingBuffer: true,
          picking_uEnable: true
        },
        layers: this.layers,
        mode: mode,
        viewport: this.context.viewport,
        pickingFBO: this.context.pickingFBO,
        lastPickedInfo: this.context.lastPickedInfo
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = false;

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else {
        if (this.screenCleared === true) {
          this.screenCleared = false;
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    // PRIVATE METHODS

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref6) {
      var oldLayers = _ref6.oldLayers,
          newLayers = _ref6.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var oldLayer = _step3.value;

          if (oldLayerMap[oldLayer.id]) {
            log.once(0, 'Multipe old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref7) {
      var _this = this;

      var newLayers = _ref7.newLayers,
          oldLayerMap = _ref7.oldLayerMap,
          generatedLayers = _ref7.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step4.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              log.once(0, 'Multipe new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '=>', newLayer);
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);
            } else {
              _this._initializeNewLayer(newLayer);
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var sublayers = newLayer.renderLayers();
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      assert(state, 'deck.gl sanity check - Matching layer has no state');
      assert(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');

      // Move state
      newLayer.state = state;
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      state.layer = newLayer;

      // Update model layer reference
      if (state.model) {
        state.model.userData.layer = newLayer;
      }
      // Keep a temporary ref to the old props, for prop comparison
      newLayer.oldProps = props;
      // oldLayer.state = null;
      oldLayer.lifecycle = LIFECYCLE.OUTDATED;
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;

          if (layer.lifecycle !== LIFECYCLE.OUTDATED) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {
          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });
          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          log.once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = LIFECYCLE.FINALIZED;
        log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }
  }]);

  return LayerManager;
}();

export default LayerManager;


function layerName(layer) {
  if (layer instanceof Layer) {
    return '' + layer;
  }
  return !layer ? 'null layer' : 'invalid layer';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImxvZyIsImFzc2VydCIsImRyYXdMYXllcnMiLCJwaWNrTGF5ZXJzIiwiTElGRUNZQ0xFIiwiVmlld3BvcnQiLCJGcmFtZWJ1ZmZlck9iamVjdCIsIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwiTGF5ZXJNYW5hZ2VyIiwiZ2wiLCJwcmV2TGF5ZXJzIiwibGF5ZXJzIiwic2NyZWVuQ2xlYXJlZCIsIm9sZENvbnRleHQiLCJjb250ZXh0IiwidW5pZm9ybXMiLCJ2aWV3cG9ydCIsInZpZXdwb3J0Q2hhbmdlZCIsInBpY2tpbmdGQk8iLCJsYXN0UGlja2VkSW5mbyIsImluZGV4IiwibGF5ZXJJZCIsIk9iamVjdCIsInNlYWwiLCJhc3NpZ24iLCJuZXdMYXllcnMiLCJmaWx0ZXIiLCJuZXdMYXllciIsImxheWVyIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwicGFzcyIsIngiLCJ5IiwibW9kZSIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2tpbmdfdUVuYWJsZSIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJsZW5ndGgiLCJnZXROZWVkc1JlZHJhdyIsIm9sZExheWVyTWFwIiwib2xkTGF5ZXIiLCJpZCIsIm9uY2UiLCJsYXllck5hbWUiLCJfbWF0Y2hTdWJsYXllcnMiLCJlcnJvcjIiLCJfZmluYWxpemVPbGRMYXllcnMiLCJmaXJzdEVycm9yIiwiX3RyYW5zZmVyTGF5ZXJTdGF0ZSIsIl91cGRhdGVMYXllciIsIl9pbml0aWFsaXplTmV3TGF5ZXIiLCJwdXNoIiwic3VibGF5ZXJzIiwicmVuZGVyTGF5ZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInBhcmVudExheWVyIiwiZXJyIiwic3RhdGUiLCJwcm9wcyIsImxpZmVjeWNsZSIsIk1BVENIRUQiLCJtb2RlbCIsInVzZXJEYXRhIiwib2xkUHJvcHMiLCJPVVREQVRFRCIsIl9maW5hbGl6ZUxheWVyIiwiaW5pdGlhbGl6ZUxheWVyIiwiY2hhbmdlRmxhZ3MiLCJkaWZmUHJvcHMiLCJJTklUSUFMSVpFRCIsInVwZGF0ZUxheWVyIiwiZmluYWxpemVMYXllciIsIkZJTkFMSVpFRCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBT0EsS0FBUCxNQUFrQixTQUFsQjtBQUNBLFNBQVFDLEdBQVIsUUFBa0IsU0FBbEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMseUJBQVIsRUFBb0JDLFVBQXBCLFFBQXFDLGlCQUFyQztBQUNBLFNBQVFDLFNBQVIsUUFBd0IsYUFBeEI7QUFDQSxTQUFRQyxRQUFSLFFBQXVCLGFBQXZCOztBQUVBLFNBQVFDLGlCQUFSLFFBQWdDLFNBQWhDOztBQUVBLElBQU1DLHlCQUF5QixDQUEvQjtBQUNBLElBQU1DLCtCQUErQixDQUFyQzs7SUFFcUJDLFk7QUFDbkIsOEJBQWtCO0FBQUEsUUFBTEMsRUFBSyxRQUFMQSxFQUFLOztBQUFBOztBQUNoQixTQUFLQyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEVBQWQ7QUFDQTtBQUNBO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixLQUFyQjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLQyxPQUFM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QUFTLENBQVQsNENBQzBDQyxVQUFVdEIsS0FBVixDQUQxQyxFQUM4RHFDLEdBRDlEO0FBRUE7QUFDQWxDLGtCQUFRa0MsR0FBUjtBQUNEO0FBQ0Q7QUFDQXJDLGNBQU13QyxTQUFOLEdBQWtCakUsVUFBVThFLFNBQTVCO0FBQ0FsRixZQUFJTyxzQkFBSixrQkFBMEM0QyxVQUFVdEIsS0FBVixDQUExQztBQUNEO0FBQ0QsYUFBT0csS0FBUDtBQUNEOzs7Ozs7ZUFwVWtCdkIsWTs7O0FBdVVyQixTQUFTMEMsU0FBVCxDQUFtQnRCLEtBQW5CLEVBQTBCO0FBQ3hCLE1BQUlBLGlCQUFpQjlCLEtBQXJCLEVBQTRCO0FBQzFCLGdCQUFVOEIsS0FBVjtBQUNEO0FBQ0QsU0FBTyxDQUFDQSxLQUFELEdBQVMsWUFBVCxHQUF3QixlQUEvQjtBQUNEIiwiZmlsZSI6ImxheWVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gSU1MRU1FTlRBVElPTiBOT1RFUzogV2h5IG5ldyBsYXllcnMgYXJlIGNyZWF0ZWQgb24gZXZlcnkgcmVuZGVyXG4vL1xuLy8gVGhlIGtleSBoZXJlIGlzIHRvIHVuZGVyc3RhbmQgdGhlIGRlY2xhcmF0aXZlIC8gZnVuY3Rpb25hbFxuLy8gcHJvZ3JhbW1pbmcgbmF0dXJlIG9mIFwicmVhY3RpdmVcIiBhcHBsaWNhdGlvbnMuXG4vL1xuLy8gLSBJbiBhIHJlYWN0aXZlIGFwcGxpY2F0aW9uLCB0aGUgZW50aXJlIFwiVUkgdHJlZVwiXG4vLyAgIGlzIHJlLXJlbmRlcmVkIGV2ZXJ5IHRpbWUgc29tZXRoaW5nIGluIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxuLy9cbi8vIC0gVGhlIFVJIGZyYW1ld29yayAoc3VjaCBhcyBSZWFjdCBvciBkZWNrLmdsKSB0aGVuIGRpZmZzIHRoZSByZW5kZXJlZFxuLy8gICB0cmVlIG9mIFVJIGVsZW1lbnRzIChSZWFjdCBFbGVtZW50cyBvciBkZWNrLmdsIExheWVycykgYWdhaW5zdCB0aGVcbi8vICAgcHJldmlvdXNseSB0cmVlIGFuZCBtYWtlcyBvcHRpbWl6ZWQgY2hhbmdlcyAodG8gdGhlIERPTSBvciB0byBXZWJHTCBzdGF0ZSkuXG4vL1xuLy8gLSBEZWNrLmdsIGxheWVycyBhcmUgbm90IGJhc2VkIG9uIFJlYWN0LlxuLy8gICBCdXQgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHdyYXAgZGVjay5nbCBsYXllcnMgaW4gUmVhY3QgY29tcG9uZW50cyB0b1xuLy8gICBlbmFibGUgdXNlIG9mIEpTWC5cbi8vXG4vLyBUaGUgZGVjay5nbCBtb2RlbCB0aGF0IGZvciB0aGUgYXBwIGNyZWF0ZXMgYSBuZXcgc2V0IG9mIG9uIGxheWVycyBvbiBldmVyeVxuLy8gcmVuZGVyLlxuLy8gSW50ZXJuYWxseSwgdGhlIG5ldyBsYXllcnMgYXJlIGVmZmljaWVudGx5IG1hdGNoZWQgYWdhaW5zdCBleGlzdGluZyBsYXllcnNcbi8vIHVzaW5nIGxheWVyIGlkcy5cbi8vXG4vLyBBbGwgY2FsY3VsYXRlZCBzdGF0ZSAocHJvZ3JhbXMsIGF0dHJpYnV0ZXMgZXRjKSBhcmUgc3RvcmVkIGluIGEgc3RhdGUgb2JqZWN0XG4vLyBhbmQgdGhpcyBzdGF0ZSBvYmplY3QgaXMgbW92ZWQgZm9yd2FyZCB0byB0aGUgbWF0Y2ggbGF5ZXIgb24gZXZlcnkgcmVuZGVyXG4vLyBjeWNsZS4gIFRoZSBuZXcgbGF5ZXIgZW5kcyB1cCB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgb2xkIGxheWVyIChhbmQgdGhlXG4vLyBwcm9wcyBvZiB0aGUgbmV3IGxheWVyKSwgd2hpbGUgdGhlIG9sZCBsYXllciBpcyBzaW1wbHkgZGlzY2FyZGVkIGZvclxuLy8gZ2FyYmFnZSBjb2xsZWNpb24uXG4vL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdHJ5LWNhdGNoICovXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge2RyYXdMYXllcnMsIHBpY2tMYXllcnN9IGZyb20gJy4vZHJhdy1hbmQtcGljayc7XG5pbXBvcnQge0xJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuXG5pbXBvcnQge0ZyYW1lYnVmZmVyT2JqZWN0fSBmcm9tICdsdW1hLmdsJztcblxuY29uc3QgTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSA9IDI7XG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SID0gMztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioe2dsfSkge1xuICAgIHRoaXMucHJldkxheWVycyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLy8gVHJhY2tzIGlmIGFueSBsYXllcnMgd2VyZSBkcmF3biBsYXN0IHVwZGF0ZVxuICAgIC8vIE5lZWRlZCB0byBlbnN1cmUgdGhhdCBzY3JlZW4gaXMgY2xlYXJlZCB3aGVuIG5vIGxheWVycyBhcmUgc2hvd25cbiAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9sZENvbnRleHQgPSB7fTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBnbCxcbiAgICAgIHVuaWZvcm1zOiB7fSxcbiAgICAgIHZpZXdwb3J0OiBudWxsLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiB0cnVlLFxuICAgICAgcGlja2luZ0ZCTzogbnVsbCxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgbGF5ZXJJZDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LnNlYWwodGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHNldFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgYXNzZXJ0KHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQsICdJbnZhbGlkIHZpZXdwb3J0Jyk7XG5cbiAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgLy8gY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgLy8gY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gIW9sZFZpZXdwb3J0IHx8ICF2aWV3cG9ydC5lcXVhbHMob2xkVmlld3BvcnQpO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmICh2aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vbGRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udGV4dC51bmlmb3JtcyA9IHt9O1xuICAgICAgbG9nKDQsIHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgY29uc3Qge2Vycm9yLCBnZW5lcmF0ZWRMYXllcnN9ID0gdGhpcy5fdXBkYXRlTGF5ZXJzKHtcbiAgICAgIG9sZExheWVyczogdGhpcy5wcmV2TGF5ZXJzLFxuICAgICAgbmV3TGF5ZXJzXG4gICAgfSk7XG5cbiAgICB0aGlzLmxheWVycyA9IGdlbmVyYXRlZExheWVycztcbiAgICAvLyBUaHJvdyBmaXJzdCBlcnJvciBmb3VuZCwgaWYgYW55XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkcmF3TGF5ZXJzKHtwYXNzfSkge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXIuZHJhd0xheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgZHJhd0xheWVycyh7bGF5ZXJzOiB0aGlzLmxheWVycywgcGFzc30pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwaWNrTGF5ZXIoe3gsIHksIG1vZGV9KSB7XG4gICAgY29uc3Qge2dsLCB1bmlmb3Jtc30gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBTZXQgdXAgYSBmcmFtZSBidWZmZXIgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuY29udGV4dC5waWNraW5nRkJPID09PSBudWxsIHx8XG4gICAgICBnbC5jYW52YXMud2lkdGggIT09IHRoaXMuY29udGV4dC5waWNraW5nRkJPLndpZHRoIHx8XG4gICAgICBnbC5jYW52YXMuaGVpZ2h0ICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gbmV3IEZyYW1lYnVmZmVyT2JqZWN0KGdsLCB7XG4gICAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwaWNrTGF5ZXJzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgIHBpY2tpbmdfdUVuYWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICBtb2RlLFxuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuY29udGV4dC5waWNraW5nRkJPLFxuICAgICAgbGFzdFBpY2tlZEluZm86IHRoaXMuY29udGV4dC5sYXN0UGlja2VkSW5mb1xuICAgIH0pO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGlmICghdGhpcy5jb250ZXh0LnZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnNjcmVlbkNsZWFyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBsYXllci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gTWF0Y2ggYWxsIGxheWVycywgY2hlY2tpbmcgZm9yIGNhdWdodCBlcnJvcnNcbiAgLy8gVG8gYXZvaWQgaGF2aW5nIGFuIGV4Y2VwdGlvbiBpbiBvbmUgbGF5ZXIgZGlzcnVwdCBvdGhlciBsYXllcnNcbiAgX3VwZGF0ZUxheWVycyh7b2xkTGF5ZXJzLCBuZXdMYXllcnN9KSB7XG4gICAgLy8gQ3JlYXRlIG9sZCBsYXllciBtYXBcbiAgICBjb25zdCBvbGRMYXllck1hcCA9IHt9O1xuICAgIGZvciAoY29uc3Qgb2xkTGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBlIG9sZCBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG9sZExheWVyKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG9jYXRlIGFycmF5IGZvciBnZW5lcmF0ZWQgbGF5ZXJzXG4gICAgY29uc3QgZ2VuZXJhdGVkTGF5ZXJzID0gW107XG5cbiAgICAvLyBNYXRjaCBzdWJsYXllcnNcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgIG5ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXJyb3IyID0gdGhpcy5fZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKTtcbiAgICBjb25zdCBmaXJzdEVycm9yID0gZXJyb3IgfHwgZXJyb3IyO1xuICAgIHJldHVybiB7ZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVyc307XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICBfbWF0Y2hTdWJsYXllcnMoe25ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc30pIHtcbiAgICAvLyBGaWx0ZXIgb3V0IGFueSBudWxsIGxheWVyc1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIobmV3TGF5ZXIgPT4gbmV3TGF5ZXIgIT09IG51bGwpO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gMS4gZ2l2ZW4gYSBuZXcgY29taW5nIGxheWVyLCBmaW5kIGl0cyBtYXRjaGluZyBsYXllclxuICAgICAgICBjb25zdCBvbGRMYXllciA9IG9sZExheWVyTWFwW25ld0xheWVyLmlkXTtcbiAgICAgICAgb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdID0gbnVsbDtcblxuICAgICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsXG4gICAgICAgICAgICBgbWF0Y2hlZCAke2xheWVyTmFtZShuZXdMYXllcil9YCwgb2xkTGF5ZXIsICc9PicsIG5ld0xheWVyKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKTtcbiAgICAgICAgICB0aGlzLl91cGRhdGVMYXllcihuZXdMYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5ld0xheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0ZWRMYXllcnMucHVzaChuZXdMYXllcik7XG5cbiAgICAgICAgLy8gQ2FsbCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG4gICAgICAgIGxldCBzdWJsYXllcnMgPSBuZXdMYXllci5yZW5kZXJMYXllcnMoKTtcbiAgICAgICAgLy8gRW5kIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcblxuICAgICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgICAgc3VibGF5ZXJzID0gQXJyYXkuaXNBcnJheShzdWJsYXllcnMpID8gc3VibGF5ZXJzIDogW3N1YmxheWVyc107XG5cbiAgICAgICAgICAvLyBwb3B1bGF0ZSByZWZlcmVuY2UgdG8gcGFyZW50IGxheWVyXG4gICAgICAgICAgc3VibGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgICAgICAgbGF5ZXIucGFyZW50TGF5ZXIgPSBuZXdMYXllcjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgICAgICAgIG5ld0xheWVyczogc3VibGF5ZXJzLFxuICAgICAgICAgICAgb2xkTGF5ZXJNYXAsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMYXllcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIG1hdGNoaW5nIG9mICR7bGF5ZXJOYW1lKG5ld0xheWVyKX0gJHtlcnJ9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpIHtcbiAgICBjb25zdCB7c3RhdGUsIHByb3BzfSA9IG9sZExheWVyO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXNzZXJ0KHN0YXRlLCAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBoYXMgbm8gc3RhdGUnKTtcbiAgICBhc3NlcnQob2xkTGF5ZXIgIT09IG5ld0xheWVyLCAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBpcyBzYW1lJyk7XG5cbiAgICAvLyBNb3ZlIHN0YXRlXG4gICAgbmV3TGF5ZXIuc3RhdGUgPSBzdGF0ZTtcbiAgICBuZXdMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTUFUQ0hFRDtcbiAgICBzdGF0ZS5sYXllciA9IG5ld0xheWVyO1xuXG4gICAgLy8gVXBkYXRlIG1vZGVsIGxheWVyIHJlZmVyZW5jZVxuICAgIGlmIChzdGF0ZS5tb2RlbCkge1xuICAgICAgc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBuZXdMYXllcjtcbiAgICB9XG4gICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgIG5ld0xheWVyLm9sZFByb3BzID0gcHJvcHM7XG4gICAgLy8gb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5PVVREQVRFRDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gTWF0Y2hlZCBsYXllcnMgaGF2ZSBsaWZlY3ljbGUgc3RhdGUgXCJvdXRkYXRlZFwiXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5saWZlY3ljbGUgIT09IExJRkVDWUNMRS5PVVREQVRFRCkge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF9pbml0aWFsaXplTmV3TGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgIGlmICghbGF5ZXIuc3RhdGUpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmluaXRpYWxpemVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHM6IHt9LFxuICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuSU5JVElBTElaRUQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX0gJHtlcnJ9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiYWNrIHBvaW50ZXIgKHVzZWQgaW4gcGlja2luZylcbiAgICAgIGlmIChsYXllci5zdGF0ZSkge1xuICAgICAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuICAgICAgICAvLyBTYXZlIGxheWVyIG9uIG1vZGVsIGZvciBwaWNraW5nIHB1cnBvc2VzXG4gICAgICAgIC8vIFRPRE8gLSBzdG9yZSBvbiBtb2RlbC51c2VyRGF0YSByYXRoZXIgdGhhbiBkaXJlY3RseSBvbiBtb2RlbFxuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnN0YXRlICYmIGxheWVyLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfdXBkYXRlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzfSA9IGxheWVyO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci51cGRhdGVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZGVjay5nbCBlcnJvciBkdXJpbmcgdXBkYXRlIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsIGB1cGRhdGluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIEZpbmFsaXplcyBhIHNpbmdsZSBsYXllclxuICBfZmluYWxpemVMYXllcihsYXllcikge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgY29uc3Qge3N0YXRlfSA9IGxheWVyO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIuZmluYWxpemVMYXllcigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsXG4gICAgICAgICAgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyLnN0YXRlID0gbnVsbDtcbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5GSU5BTElaRUQ7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF5ZXJOYW1lKGxheWVyKSB7XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgcmV0dXJuIGAke2xheWVyfWA7XG4gIH1cbiAgcmV0dXJuICFsYXllciA/ICdudWxsIGxheWVyJyA6ICdpbnZhbGlkIGxheWVyJztcbn1cbiJdfQ==